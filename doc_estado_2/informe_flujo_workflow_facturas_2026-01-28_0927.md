# Informe: Flujo del Workflow de facturas (documentación exacta)

Fecha: 2026-01-28 09:27

Descripción: Tabla estática que documenta, sin interpretaciones ni propuestas, los pasos que ejecuta la clase `ProcesarFacturaWorkflow` desde la recepción del evento hasta la finalización, indicando funciones exactas, entradas, salidas y siguiente paso.

| ID | Nombre del paso | Función utilizada | Descripción de la operación | Entradas | Salidas | Siguiente paso en el flujo |
|----|-----------------|-------------------|-----------------------------|----------|---------|----------------------------|
| 1 | Inicio / invocación del Workflow | `ProcesarFacturaWorkflow.run` (método) | Punto de entrada del Workflow (método `run` de la clase `ProcesarFacturaWorkflow`). Recibe el evento y crea `stepRunner` para ejecutar pasos con control. | `event.payload` con: `invoiceId`, `fileUrl`, `r2Key`, `originalFileName`, `contentType` | Inicia ejecución de los pasos; no devuelve un valor final a este punto (flujo continúa). | `wf-facturas-extraer-texto` |
| 2 | wf-facturas-extraer-texto | llamadas: `fetch` (global), `putR2` (lib/storage), `getKV` (lib/storage), `callOpenAI` (lib/openai) | Descarga el PDF desde `fileUrl`, guarda el PDF en R2 (`putR2`), obtiene `OPENAI_API_KEY` y plantilla de prompts desde KV (`getKV`), construye `requestBody` reemplazando `{{ARCHIVO_URL}}` por URL pública de R2, llama a OpenAI con `callOpenAI`, y guarda el resultado JSON (`facturas-extraer-texto.json`) en R2. | Entradas directas: `invoiceId`, `fileUrl`, `r2Key`, `originalFileName`, `contentType`; también: prompt (`plantilla`) desde `NSKV_PROMPTS` y `OPENAI_API_KEY` desde `NSKV_SECRETOS`. | En caso de éxito: `documentoExito` que incluye `apioResponse` (respuesta de OpenAI) y se guarda en `facturas/${invoiceId}/facturas-extraer-texto.json`; devuelve `documentoExito`. En caso de error: `documentoError` (objeto con `error.code` y `message`) guardado en R2 y se lanza excepción. | `lectura-apioresponse` (si tiene éxito), si falla: excepción y finalización del flujo mediante throw (tras escribir error en R2). |
| 3 | lectura-apioresponse | `loadApioResponseOutput` (lib/apioresponse), `validateAndNormalizeRO` (lib/apioresponse) | Carga el JSON generado en R2 (`facturas-extraer-texto.json`) mediante `loadApioResponseOutput`, extrae `apioResponse.output` y (si aplica) parsea `output[0].content[0].text` a JSON; valida la estructura del RO y normaliza tipos con `validateAndNormalizeRO`. | `invoiceId` (para localizar `facturas/${invoiceId}/facturas-extraer-texto.json` en R2) | Si éxito: `ro` (objeto validado con `datos_generales` y `lineas`) y metadatos de lectura; devuelve un objeto con `ro` y metadatos. Si falla: lanza `ValidationFailure`. | `proveedor_fat_empresas` (si tiene éxito); si falla: escribe payload de error en R2 (`buildValidationErrorPayload`) y lanza la excepción. |
| 4 | proveedor_fat_empresas | `validateProveedorInput` (lib/proveedor), `normalizeNombreProveedor` (lib/proveedor), `resolveProveedorEmpresa` (lib/proveedor) | Valida entrada mínima requerida para proveedor, normaliza nombre del proveedor, resuelve/crea la empresa en `fat_empresas` mediante `resolveProveedorEmpresa`. | `ro` (desde paso anterior) y `metadatos` (invoiceId, r2_pdf_key, file_url, nombre_original, contentType) | Si éxito: `empresaId` (ID en `fat_empresas`), `nombreNormalizadoProveedor`; devuelve objeto con `empresaId`, `ro`, `metadatos`, `nombreNormalizadoProveedor`. Si falla: lanza `ProveedorFailure`. | `cabecera_fat_empresas` en caso de éxito; si falla: escribe error con `buildProveedorErrorPayload` en R2 y lanza excepción. |
| 5 | cabecera_fat_empresas | `validateCabeceraInput` (lib/cabecera), `normalizeNumeroFactura` (lib/cabecera), `overwriteFacturaSiExiste` (lib/cabecera), `insertarCabeceraFactura` (lib/cabecera) | Valida la cabecera (campos obligatorios), normaliza número de factura, comprueba existencia de factura idéntica y la borra si existe (`overwriteFacturaSiExiste` borra cabecera y líneas anteriores), e inserta la nueva cabecera en `fat_facturas` con `insertarCabeceraFactura`. | `ro` (datos_generales), `metadatos`, `empresaId` | Si éxito: `facturaId` (nuevo ID de `fat_facturas`) y `numeroFacturaNormalizado`; devuelve objeto con esos valores. Si falla: lanza `ValidationFailure` o `ProveedorFailure`. | `fat_facturas_archivos` (si tiene éxito); si falla: escribe error con `buildValidationErrorPayload` en R2 y lanza excepción. |
| 6 | fat_facturas_archivos (primer upsert, estado pendiente) | `upsertFacturasArchivos` (lib/archivos) | Inserta o actualiza metadata de archivo en `fat_facturas_archivos`: busca por `invoiceId`; si existe y `factura_id` distinto -> lanza `ArchivosFailure` (`inconsistente`); si existe y mismo `factura_id` -> `UPDATE` (usa `COALESCE` para `r2_excel_key`); si no existe -> `INSERT`. | Entrada: `ArchivosMetadatos` con `factura_id`, `invoiceId`, `r2_pdf_key`, `original_file_name`, `file_url`, `estado_validacion: 'pendiente'`, `r2_excel_key: null` | Salida: objeto `{ insertado: true }` o `{ actualizado: true }`. Si falla: lanza `ArchivosFailure`. | `lineas_fat_empresas` (si tiene éxito); si falla: escribe error con `buildValidationErrorPayload` en R2 y lanza excepción. |
| 7 | lineas_fat_empresas | `validateLineasInput` (lib/lineas), `borrarLineasFactura` (lib/lineas), `insertarLineasFactura` (lib/lineas) | Valida formato y campos de `ro.lineas` (todos los campos obligatorios y numéricos), elimina líneas existentes de `fat_factura_lineas` y vuelve a insertar las líneas desde el RO. | `ro.lineas`, `empresaId`, `facturaId`, `numeroFacturaNormalizado`, `nombreNormalizadoProveedor` | Si éxito: número de `lineasInsertadas` (número entero) y devuelve metadatos de líneas. Si falla: lanza `ValidationFailure` o `LineasFailure`. | `excel_fat_empresas` (si tiene éxito); si falla: escribe error con `buildValidationErrorPayload` en R2 y lanza excepción. |
| 8 | excel_fat_empresas | `obtenerCabeceraFacturaExcel` (lib/excel), `obtenerLineasFacturaExcel` (lib/excel), `buildExcelBuffer` (lib/excel), `buildExcelKeyFromPdfKey` (local en workflow.ts), `putExcelInR2` (lib/excel), `upsertFacturasArchivos` (lib/archivos) | Recupera datos de cabecera y líneas desde D1, genera un buffer XLSX con `buildExcelBuffer`, construye `excelKey` (`buildExcelKeyFromPdfKey`), sube el Excel a R2 con `putExcelInR2`, y actualiza `fat_facturas_archivos` estableciendo `estado_validacion: 'validada'` y `r2_excel_key: excelKey`. | `empresaId`, `facturaId`, `metadatos`, `numeroFacturaNormalizado`, `nombreNormalizadoProveedor` | Si éxito: `excelKey` (ruta/clave en R2) y confirmación de actualización en `fat_facturas_archivos`. Si falla: lanza excepción y escribe `buildValidationErrorPayload` en R2. | Fin del flujo (si tiene éxito devuelve información de Excel y metadatos); si falla: error persistente en R2 y throw. |

Notas estrictas (documentación exacta):
- Todas las funciones citadas arriba corresponden a llamadas tal y como aparecen en el código fuente: `src/workflow.ts`, `src/lib/*.ts`.
- El paso explícito que realiza la llamada a OpenAI es `wf-facturas-extraer-texto`, donde se invoca `callOpenAI(apiKey, requestBody, fetch)`. El resultado de `callOpenAI` se almacena en `documentoExito.apioResponse` y se persiste en R2 (`facturas/${invoiceId}/facturas-extraer-texto.json`). En caso de error en esa llamada o en cualquier operación dentro del paso, el `catch` escribe un objeto de error (`documentoError`) en R2 y relanza la excepción.
- El procesamiento deja rastros en R2 (archivos `facturas/${invoiceId}/facturas-extraer-texto.json` y, en error, `facturas/${invoiceId}/facturas-extraer-texto-ERROR_<timestamp>.json` y `error_validacion_factura.json`).

Archivo generado automáticamente y guardado en `doc_estado_2/informe_flujo_workflow_facturas_2026-01-28_0927.md`.
