1. Resumen ejecutivo
- Se mantendrá WK1 (HTTP) sin cambios y se creará WK2 con trigger Email para extraer adjuntos PDF, subirlos a R2 y lanzar el mismo Workflow.
- Es necesario confirmar nombres, bindings y rutas R2, así como la configuración de Email Routing para dirigir correos al Worker WK2.

2. Tarea 1 — Información requerida al usuario
| ID | Elemento requerido | Descripción | Valor detectado en la configuración actual | Requiere validación del usuario |
| --- | --- | --- | --- | --- |
| 1 | Nombre Worker HTTP (WK1) | Nombre final del Worker existente | wf-procesar-factura (wrangler.name) | sí |
| 2 | Nombre Worker Email (WK2) | Nombre a usar en wrangler.toml y despliegue | sugerido: wf-procesar-factura-email (alineado con WK1) | sí |
| 3 | Dominio/alias Email Routing | Dominio y dirección que recibirán los correos para WK2 | (no definido en repo) | sí |
| 4 | Regla Email Routing → Worker | Mapeo de dirección entrante hacia WK2 (Email Worker) | (no definido en repo) | sí |
| 5 | Bucket R2 para PDFs | Bucket donde guardar los PDFs de email | r2-facturas-archivos (binding R2_FACTURAS en WK1) | sí (confirmar reutilización) |
| 6 | Prefijo/ruta en R2 | Carpeta/prefijo para los PDFs recibidos por email | sin prefijo fijo en WK1; r2Key se pasa en payload (ej.: facturas/<invoiceId>/...) | sí |
| 7 | Binding Workflow | Nombre del binding para lanzar el Workflow | WF_PROCESAR_FACTURA (wrangler) | sí (confirmar mismo binding en WK2) |
| 8 | KV Secrets | Necesidad de leer tokens/llaves en WK2 (p.ej. validación remitente) | NSKV_SECRETOS (existe en WK1) | sí (confirmar uso en WK2) |
| 9 | KV Prompts | Si WK2 necesita prompts (probable no) | NSKV_PROMPTS (existe en WK1) | sí (confirmar no uso en WK2) |
| 10 | D1 Database | Si WK2 requiere D1 (probable no) | DB_FAT_EMPRESAS (existe en WK1) | sí (confirmar no uso en WK2) |
| 11 | Payload esperado por Workflow | Campos exactos requeridos por Workflow (invoiceId, r2Key, originalFileName, contentType, fileUrl) | Detectado en WK1/Workflow | sí (confirmar invariantes) |
| 12 | Generación de invoiceId | Estrategia para invoiceId al llegar por email (UUID vs derivado) | WK1 usa crypto.randomUUID() antes de crear Workflow | sí |
| 13 | URL pública de R2 | Dominio público R2 o Signed URL para fileUrl | pub-4e5e6e57e45848fbbbec281180517b6e.r2.dev (observado en Workflow) | sí (confirmar uso) |
| 14 | Entornos | Producción / staging y cuentas Cloudflare implicadas | Cuenta actual (último deploy): 15415870ae5f154bf2baf3f835300403 | sí |
| 15 | Límites operativos | Tamaño máximo permitido de adjuntos y política de rechazo | Email Workers: ~25MB por email (doc), Worker memory ~128MB | sí (confirmar política) |

3. Tarea 2 — Plan de implementación WK2
- Paso 1: Copiar estructura de WK1 a un nuevo directorio (p.ej., workers/wf-procesar-factura-email/) manteniendo package.json/tsconfig si aplica.
- Paso 2: Crear wrangler.toml para WK2 con `main` apuntando a un nuevo entrypoint (p.ej., src/email.ts), nombre distinto y bindings necesarios: R2_FACTURAS, WF_PROCESAR_FACTURA, (opcional) NSKV_SECRETOS; omitir KV/D1 si no se usan.
- Paso 3: Añadir handler `export default { async email(message, env, ctx) { ... } }` siguiendo el modelo Email Workers; extraer el primer adjunto PDF (`message.attachments`), validar content-type `application/pdf` y tamaño según límites.
- Paso 4: Subir el PDF a R2 via `env.R2_FACTURAS.put(r2Key, stream/arrayBuffer, { httpMetadata: { contentType: 'application/pdf' } })`; construir `r2Key` y `fileUrl` (usando dominio público R2 existente o signed URL).
- Paso 5: Construir payload alineado con WK1: { invoiceId, r2Key, originalFileName, contentType, fileUrl } y llamar `env.WF_PROCESAR_FACTURA.create({ id: invoiceId, params: payload })`.
- Paso 6: Responder 200 con JSON que incluya instancia_id y metadatos; manejar errores con respuestas claras (4xx para validación, 5xx para fallos R2/Workflow).
- Paso 7: Configurar Email Routing en Cloudflare: crear regla que entregue correos a WK2 (Email Worker) para la(s) dirección(es) definidas.
- Paso 8: Desplegar WK2 con `wrangler deploy`; probar con email de prueba con PDF y validar que el Workflow recibe el payload.
- Paso 9: Añadir tests mínimos (unit o integration) para el handler email: validación de MIME, tamaño, ausencia de adjuntos, éxito con PDF válido (si el stack actual usa vitest, se puede añadir en test/ separado).
- Paso 10: Documentar en README de WK2 el flujo y bindings.

4. Tarea 3 — Consideraciones adicionales
- Requisitos: confirmar dominio y regla de Email Routing, almacenamiento en R2 (bucket y prefijo), URL pública/signed para `fileUrl`, y generación de `invoiceId` consistente.
- Límites documentados: Email Workers admiten emails hasta ~25MB; Workers tienen límites de CPU y memoria (ver docs). Validar tamaño antes de leer todo en memoria; preferir `attachment.stream()` cuando sea posible.
- Riesgos: adjuntos múltiples (elegir uno o rechazar), tipos MIME engañosos (validar magic number si es crítico), correos sin adjuntos, nombres de archivo duplicados en R2 (usar UUID/prefijo por fecha).
- Buenas prácticas: usar `email` trigger separado; respuestas rápidas (<15s); registrar logs mínimos (sin datos sensibles); manejar errores con códigos claros.
- Observabilidad: activar logs de Worker, considerar envío de métricas (Durable Object/Analytics Engine) si ya existen; probar en staging antes de producción.

5. Conclusión técnica
- WK1 permanece intacto; WK2 deberá implementar handler `email` que normalice el adjunto PDF al payload existente y llame al mismo Workflow. 
- El plan se basa en reutilizar bindings y esquema de payload; los cambios se limitan al trigger y al origen del archivo.
