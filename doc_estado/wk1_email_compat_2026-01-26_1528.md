1. Resumen ejecutivo
- El Worker actual (WK1) solo procesa peticiones HTTP `fetch` con cuerpo JSON y no contiene lógica para extraer adjuntos ni para manejar el modelo `EmailMessage` de Email Workers. 
- Según la documentación oficial de Email Workers, los eventos de email no exponen `Request` ni `Body` JSON, sino un objeto `EmailMessage` con adjuntos accesibles vía `message.attachments`. WK1 no puede manejar ese modelo sin cambios. 
- Para soportar adjuntos desde Email Trigger manteniendo compatibilidad con el front, se requieren adaptaciones (opción 1) o un Worker separado (opción 2). También se plantea una alternativa basada en enrutar correo a R2 vía Email Routing + Webhook HTTP (opción 3).

2. Evaluación de compatibilidad sin cambios (Tarea 1)
- Modelo actual WK1: espera `Request` HTTP POST con JSON { invoiceId, r2Key, originalFileName, contentType, fileUrl } y llama `env.WF_PROCESAR_FACTURA.create`. No lee binarios, no parsea multipart, no usa `request.arrayBuffer()`. [workers/wf-procesar-factura/src/index.ts](workers/wf-procesar-factura/src/index.ts#L6-L29)
- Modelo Email Workers: handler `async email(message, env, ctx)` recibe `message` (no `Request`); adjuntos accesibles como `message.attachments[]` (Array<EmailMessageAttachment>) con métodos `stream()`/`arrayBuffer()`, headers MIME propios. Fuente: Cloudflare Email Workers docs.
- Incompatibilidades: distinto entrypoint (`email` vs `fetch`), distinta forma de acceder a adjuntos, ausencia de campos JSON esperados por WK1, y WK1 no persiste el PDF. Conclusión: NO es posible reutilizar WK1 sin cambios para Email Trigger.

3. Evaluación opción 1: Adaptar WK1
- Cambios necesarios:
  - Exponer doble handler o unificado: `fetch` (actual) y `email` (nuevo) en el mismo bundle (Workers permite ambos triggers en un Worker script).
  - Normalizar entrada: del `EmailMessage` construir un objeto equivalente al payload que WK1 espera (ej. generar `fileUrl` usando R2 put previo, derivar `originalFileName` de `attachment.filename`, `contentType` de `attachment.contentType`, `r2Key` calculado) y generar un `invoiceId` (UUID) si no viene en el email.
  - Añadir lógica de ingestión: leer el attachment (size check según límites Email Workers; adjuntos <= 25MB aprox.) y subirlo a R2 (`env.R2_FACTURAS.put`) antes de llamar al Workflow para producir `fileUrl`/`r2Key` reales.
  - Validar MIME y tamaño de adjunto antes de R2.put (documentado límite de 25MB email payload y Worker memory ~128MB en Workers). 
  - Mantener flujo actual para HTTP: seguir aceptando JSON; opcionalmente permitir multipart si se desea converger.
- Impacto en mantenibilidad: mayor complejidad en un solo script (dos triggers, dos rutas de normalización), pero un único despliegue y un único binding del Workflow. Necesita pruebas diferenciadas para email y HTTP.

4. Evaluación opción 2: Duplicar en WK2
- WK2: nuevo Worker con trigger `email` dedicado. 
- Cambios en WK2:
  - Implementar handler `email(message, env, ctx)`, extraer primer attachment PDF, validar MIME/tamaño, subir a R2, construir payload y llamar al mismo Workflow (o a otro binding) con `env.WF_PROCESAR_FACTURA.create`.
  - Reutilizar utilidades compartidas: helpers de R2 (pueden extraerse de storage.ts o implementarse inline), generación de UUID y construcción de payload.
- Ventajas: separación clara de responsabilidades; menor riesgo de mezclar lógicas; permite configuraciones de bindings específicas (p.ej. distintos buckets o límites). 
- Inconvenientes: doble despliegue/configuración wrangler; duplicación parcial de código si no se factoriza una librería común.

5. Evaluación opción 3: Alternativa propuesta
- Alternativa: Mantener WK1 solo para HTTP y añadir un Email Worker mínimo que reenvíe el adjunto a WK1 vía HTTP (signed request) o lo deposite en R2 y envíe solo metadatos vía HTTP a WK1.
  - Flujo: `email` trigger -> sube attachment a R2 (o usa `message.raw`), luego hace `fetch` a la URL de WK1 con JSON { invoiceId, r2Key, originalFileName, contentType, fileUrl }. 
  - Pros: WK1 permanece sin cambios; reutiliza pipeline actual; el Email Worker actúa como adaptador.
  - Contras: dos Workers y doble salto; requiere exponer WK1 públicamente o con token; más latencia.

6. Comparativa final
| Opción | Cambios en WK1 | Workers totales | Complejidad | Código compartido | Pros | Contras |
| --- | --- | --- | --- | --- | --- | --- |
| Sin cambios | Ninguno | 1 | Baja | n/a | Cero esfuerzo | No funciona con Email Trigger |
| 1) Adaptar WK1 | Añadir handler email + normalización + R2 put | 1 | Media | Alto (mismo bundle) | Un solo despliegue; rutas unificadas | Complejidad mezclada; testing doble |
| 2) WK2 dedicado email | WK1 intacto; nuevo WK2 email | 2 | Media | Medio (helpers comunes) | Separación de concerns; despliegues independientes | Más recursos y config; duplicación parcial |
| 3) Email adapter -> HTTP WK1 | WK1 intacto; Email Worker adaptador | 2 | Media | Bajo | WK1 sin cambios; clara frontera | Más saltos/red; necesidad de endpoint público/token |

7. Conclusión técnica
- No es viable usar WK1 sin cambios para Email Trigger debido a diferencias de modelo de evento (`Request` vs `EmailMessage`) y ausencia de manejo de adjuntos.
- Opción más directa para coexistir HTTP+Email en un solo despliegue: adaptar WK1 (opción 1) añadiendo handler `email` que suba el adjunto a R2 y construya el payload que ya consume el Workflow. Requiere normalizar metadatos y validar MIME/tamaño.
- Si se prioriza aislar responsabilidades y configuraciones, opción 2 (WK2 dedicado email) es más limpia operativamente, a costa de un segundo despliegue.
- La alternativa 3 sirve si se desea cero cambios en WK1, pero introduce un adaptador adicional y un salto HTTP extra.
